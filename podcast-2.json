{
	"podcast_title" : "Rework",
	"episode_transcript" : "Welcome to Rework, a podcast by 37Signals about the better way to work and run your business. I'm your host, Kimberly Rhodes. 37Signals is in the business of software development, but their founders Jason Fried and David Heinemeyer Hansen readily admit that creating software that is completely bug-free is unrealistic. Jason and David are here to talk more about this. David, I'm going to start with you. I think some listeners might be surprised to hear the CTO of a company saying like, yeah, bugs are normal. Yes, I think that is simply accepting reality, which is a really good place to start if you want to have some impact on reality and if you want to be able to be realistic about what you can do about it. I think I'm not entirely sure where this started, but as long as I can remember, bugs have had this relationship to guilt when it comes to software development, that a bug is a representation of our human failings as programmers, as designers, as product makers, which I think is quite unfortunate when it's so prevalent. If bugs were something that very rarely happened and it only happened through sheer negligence or malice, okay, fair enough. We could assign all this guilt to it because it is something that would be clearly preventable. Now, we've dealt with software for the better part of 50 plus years. Every piece of software in that entire time has had bugs if it had any serious complexity or any users. There's basically only two types of software that does not have bugs, either the kind of stuff that doesn't get used by anyone or the stuff that is so simple it can fit on a single sheet of paper. Anything more complicated than that will have bugs and accepting that and dealing with it in a measured, logical, not overly emotional way, I think is just the only reasonable, mature response to software development if you're going to be in it for the long run because when we assign this level of guilt to it, we just end up in a place where we're feeling bad about a natural side effect of what we're doing. We could stop making bugs, but that would also mean we would stop making software. Is that a good trade? No. Most software, in fact, I would say what's really interesting, the really interesting cases are the pieces of software that are written with bugs and people continue to use because the value of that piece of software is higher than the annoyance with the bugs. I've had pieces of software in my history where I've been really annoyed with some bugs that seem glaring and obvious, which is this other telltale, and I kept using it because it was just so valuable. What an individual user often misses is that what makes a bug glaring and obvious to them is how they use that software. There's a ton of other people who don't see those same glaring bugs because they don't use the software in the same way. They don't have the same kind of data. They didn't input it in that way. They didn't use that combination of features in the way that triggers that bug. But as we always are, we're so myopic, we think the way we use something is the same way that everyone else uses it, and we just can't believe why couldn't they see this. If you realize that most people use any serious piece of software, any complicated piece of software in many different ways, it's a little easier to understand. Now, all that being said, people will absolutely stop using software that's of low quality and low value. This isn't like permission just to push in all the bugs or not care about bugs or never fix bugs. We will literally drop everything at 37signals. We have two levels of dropping everything. We have what we call code red. That is, there's a really serious bug that might be causing data loss or presenting as data loss. That's usually the kind of things that we have. It looks like the customer lost some data, but actually it was just not visible or prevent someone from accessing data that they need. That's the kind of stuff. We just drop everything, go straight to the bug, pull as many people in to dealing with it as possible, and then we work on it until it's fixed. We actually just had one of these cases on the Hey email system where we had this bug where people using the iOS app on a slower network connection would end up seeing this configuration error. Those are the most annoying bugs, by the way, when it's misdirection. It's telling you that the problem with you using it is something that makes no sense. I think anyone has used a piece of software they see, oh yeah, this is error code minus 100. Basically, it doesn't make any sense. Users justifiably get really frustrated with stuff like that. We had one of those cases, and for a while we thought it was on the slow burner. And then there was just enough, it had been going on for too long, it had affected enough people. We were like, no, actually this is just graduated. This went from one of those bugs where bugs are not special. We're just going to prioritize this maybe next cycle or whatever to, nope, this was first a code yellow, and then we couldn't quite fix it in a week, and then we made it a code red. So thinking of the graduation with bugs and the fact that there's a whole spectrum of them, there's the fact that any complicated piece of software will have probably hundreds of open bugs. Many of them will never be fixed, never. It's not like we work on a first in, first out order here where you see a bug, then you log it, and then you know eventually someone's going to fix it. No, I guarantee you we have bugs in Basecamp that have been there for 10 years. Absolutely. I mean, we have prior versions of Basecamp that we're still selling that just have the original bugs in them, and they will have those bugs until the end of time. They're like these actual physical bugs that were captured in Ember, and you can still see, oh, this is a mosquito that's 2.4 million years old. So you have that, and you have that in every piece of complicated software, but then you also have the other kind, right? So a non-emotional approach to handling bugs is to A, accept that they will always have it. B, realize that there are different kinds of bugs. We call everything bugs when there's a piece of graphical jitter. It doesn't align right. The line breaking is wrong. Oh, this is a bug. Yeah, okay, that's a bug. Then there's the bug that like I just lost your important emails. I mean, calling both of those things bugs is doing a disservice to the latter. The latter stuff is materials, impact, whatever, loss of money, so on and so forth. The first thing is a minor annoyance at best. So separating those two things up and then just realizing that the vast majority of the bugs will be of the former kind. There will be low impact, minor annoyances. They should just be scheduled along with everything else, and some of them will never be fixed. Setting those expectations with customers in particular is sometimes difficult. Any customer we have, including when I'm a customer of someone else's software, will encounter a bug and then will think, that is the most important thing you could be working on because I just saw it. I just saw it, and it either annoyed me or it was more serious than that. You should just drop everything and fix it. If you let that sentiment translate directly into your organization, you're going to get a very screwed up product roadmap because you will never be able to finish anything of note if you're constantly just dealing with that on an interruption basis. This is actually one of the reasons I think it's such a double-edged sword to have founders do customer support in the beginning because on the one hand, it's really great that you get all this unfiltered feedback and you can instantly plow it into development. You can instantly micro-adjust where you're going, but on the other hand, it is so easy to confuse the enthusiasm a customer might have with their annoyance with, this is something we need to fix right now. The customer is very upset. I'm getting that upset. I'm passing that upset straight on to the development team. You're like, maybe you should be acting as a filter. Sometimes that's easier when you have actual customer service professionals as we do now. They can act as a filter. They record all the bugs. They will make sure that things get properly escalated if it's really serious, but a lot of the minor stuff won't reach developers with the intensity that causes these existential guilt issues of, yeah, I didn't do a good job. I'm actually a terrible programmer. I don't know. Again, all the best programs in the world, they make bugs. I make bugs all the time. Everyone makes bugs all the time. Realize that first, then treat things in a measured way as how you try to fix it. David, you mentioned a code yellow and a code red. I'm curious if you could talk us through what does that triage process look like? Can anyone declare something a yellow versus a red? How does that filtering look amongst our team? Yeah, that's a really good point. Something I think we still work on because there's a sense, I think, for most employees inside of a company that they perhaps haven't been at for a million years that calling something, for example, at us, code red means other work stops. That's a high order bit to pull. You don't want to just do that willy-nilly. If you're constantly calling code red, how are we going to get anything else done? I think the impulse is to do it too late. In fact, I'd say in at least half the cases that I can immediately recall, it was me or maybe Jason or someone else quite senior who stepped in and go, no, no, no, do you know what? This is just not acceptable. We have to call a code red since we deal with it right now. I think we try to, I try to at least convince people that code red and code yellow are kind of like the end on court. This was a concept from the Toyota production line, which when they introduced this was a completely novel idea. The Toyota production line got so good and Toyota cars are so reliable in part because of the way they approached quality assurance. The quality assurance process was we will give every worker on the assembly line the power to stop the entire line if they notice problems that should be fixed at the root. The wisdom and the insight here is that the people closest to the work will notice when things aren't right. They have the most information. The Toyota managers, they don't have the information of whether whatever, the air condition doesn't fit quite right, so it has to be jammed in a little bit and that sometimes clips a thing and that then shows up in customer recalls or returns or something, but the person doing that work actually does. If we give people the power to stop the assembly line where they notice material issues like that, we will improve the assembly line. Now the hard part here is that when you first do this, at least as the story is told in Toyota law, firstly the assembly line would stop all the time, constantly stop and you'd go like, okay well maybe you can deal with one day of that, but if you're in week two or month three, you might start getting a little nervous that all these work stoppages, you're not producing the cars, who cares if they have issues, but the cumulative effect of that is eventually you will be producing fault-free cars, which Toyota essentially does, right? I don't think there's anyone who produces internal combustion engine cars with as low a defect rate as Toyota does today and it goes exactly to this. So that's the spirit that I try to reinforce and I don't think we do nearly as good a job of this as Toyota has done, but thinking of it in these terms, anyone should be able to stop the assembly line if they notice something like that that's just out of alignment, that if we keep doing that, we're just going to keep producing issues that are going to affect a majority of customers in that regard. I was going to add one quick thing to that too. One of the things that's hard about it in the software world compared to the car world is that when a car goes off the production line and goes to it on the lot and it's sold to a customer, this isn't always true, it's less true than it used to be before, but that's a shipped product that cannot be fixed unless someone brings it back to the dealership. Now there's some over the year updates in certain brands and whatever that's happening, but in software in the world that we work, I think people are a little bit more afraid to pull the cord because software can be fixed later in a sense where a car cannot be fixed later. So I think there's something about once this thing is off the line, that problem is shipped and it's different in our world, at least software as a service. It wasn't traditionally the way in ship software where people had to press something into a CD or on floppies and send it off, but I do think people are a little bit more reticent to pull for that reason. Like, well, someone else will see it or we can just deal with it later. That's a hard thing to combat, I think, that human instinct. I think that's perhaps one of those areas where I go most aggressive on, I think the problem being here, there's too much guilt, but you can certainly also flip over in the other direction where you're just like, bugs just don't matter at all. I mean, no, they totally do matter and you do have to have some processes and some encouragement that someone is going to pull the cord to stop it. And you have to have a culture that quality matters. But I think the sense of quality is one where we build good stuff. We don't build perfect stuff because perfect is the enemy of good. Perfect is the stuff that takes forever to build. Perfect is the stuff that never gets shipped. Perfect is just a minor subset of what's valuable. When you have a commitment to building good, solid stuff, that inherently includes the willingness to make trade-offs. That, you know what, we could fix a bunch of very low priority bugs that are things are wrapping wrong or color is wrong or whatever, or we could work on something new and valuable, a feature that would benefit everyone, right? And you have to constantly trade those things off. And I think that is the art and science of software development is to be able to hold that conflict. Bugs are not great, but they will always happen if we're trying to create useful, meaningful software in a reasonable amount of time on a complicated system, right? So that's the world we live in. Let's try to make it as good as possible. I think this is one of the reasons why focusing on these processes of what can you do when there are material bugs? How do you prevent like, oh, bugs are not special from becoming, we build shitty software. As soon as you tip into, we build shitty software, you're off. What I like to think about in that regard is that focusing a bit on the habits and the process of building software, not just the outcome. So how do we build software? Well, we build software where we do automated testing. That's just one thing that just comes with the territory. We build software where the software itself, like its internal properties feel like they're of high quality. We will spend time polishing the appearance, the aesthetics, the beauty of the software that we're building, because in part, one of the derivative effects is that when you care a lot about how something looks and simplifying it, it gets easier to spot the obvious bugs. It gets easier to actually attain a certain level of quality. So when you have the habits of like, we build good stuff of high quality, I think you're already quite well underway to ending up in a reasonable place where you accept the fact that there are some bugs, we fix the important or difficult ones or the most impactful ones right away and most everything else we leave to the side. And most of all, you have the, I want to say almost moral stamina to keep going. I've seen people get absolutely destroyed by guilt over bugs. This often happens in open source development where the customers aren't even paying you, if you want to put it in that way, right? Like they're benefiting from your part-time gifts and then they show up, oh, it has a bug and blah, blah, blah, blah, blah, blah. And then you go like, oh man, I'm also just such a bad programmer because I didn't see this all right now. No, no, no, please stop, right? Just stop. First of all, you're making something of value. That's why they're complaining. And this should already dilute the level of complaint that they're giving you. But also if you're focusing on just building stuff to the best of your ability and you're constantly striving to improve, it's not going to be any better. This is one of these things that sometimes does get me frustrated when good software developers are kind of written by guilt over the occasional bug they put in. What's the alternative? If you're already putting in the best of your ability, do you have another 20% of capacity? If so, why weren't you just using it all the time, right? So there's just some bad thought patterns that I think programmers in particular are susceptible to falling into that you should break out of while still maintaining, we build good stuff. Okay. I know a lot of people like to hear how 37signals is organized. So tell me a little bit about who is fixing bugs? Is it just the on-call team? Are designers and developers fixing bugs? How does that look structurally at the company? So the way we do it generally is if it's a serious bug that warrants the call of a code, particularly code red, we will pull in whoever worked on that feature because they have the most information about how that works. And then we also have this sense of if we're launching something within that same cycle, especially during cool down, so we'll work for six weeks and then we take two weeks of cool down, you'll work on something, let's say for six weeks, you'll push it out. And then in the first week, you'll find 80% of the issues if you're pushing to a large enough customer base. The team who just worked on that is responsible for cleaning it up. But after that phase, it is everyone's job to ensure that we have software of high quality. And we have a couple of different methods of doing this. One is we have what's called the on-call rotation, where we have two programmers who will work on just fixing issues and answering questions and correcting data for a week at the time. And it is their responsibility to fix minor things that can be fixed within the scope of that week. So let's say a customer found some edge case, they report that to support, support goes like, oh yeah, that's really an issue. They'll bubble it up to the on-call team, the on-call team will take a look, and if it's something small they can fix right away, they'll fix it right away. If it's something that's urgent and important, they might call a code. If it's not something they can fix right away, it's not urgent and important to put a code on, they will put it on what people sometimes call the backlog. I like to call it like a forget drawer, because it essentially gets put into a place where like, you know what, there's a fairly high likelihood this is never going to get fixed. That is the category of bugs, that it is not urgent, that it's been, or it's a result of interactions in software that are rare, and that it's lived there for a long time without someone else reporting it to. Those are three attributes of bugs that are highly unlikely to be fixed, unless against they have that high criticality. Because it means that, you know what, if it really was important, someone else would have found it sooner. If it was really dire, we would have bubbled it up to a code. And then we put it on these long lists, and we do have some quite long lists, and I'm sure you can find lists for previous versions of Basecamp, still in Basecamp somewhere detailing, oh, here's like 80 bugs related to something never going to get fixed, right? And then occasionally what we also have is that we will dive into that drawer of probably never going to be fixed bugs, and fix them occasionally. We have done two things. We've run spring cleaning. I think that just sounds good, and it has a nice metaphor to it. So in the spring, occasionally, we will dedicate either a whole cycle or part of a cycle to fix something, and then at the end of the year, the way our six cycles a year usually line up is that we will finish our last cycle in the beginning of December, and then December is already this kind of, I don't know if it's a messy month, but it's a month that you have a lot of people out and so forth, so we will dedicate the rest of that month to just fixing issues that otherwise wouldn't merit full prioritization. So you can have all these interleaving and overlapping ways of doing it, but I think ultimately you have to think of it in terms of like, where's our overall quality? If I had a sense, if Jason had a sense, do you know what? Customers are not picking Basecamp, or they're stopping to use Basecamp because they just keep hitting issues, that it's a low quality product. Absolutely, I would stop all feature development, and I will get to the root of that. But if you have a diligent approach to building software, hopefully that's not where you are. I mean, it does happen all the time that people dig themselves into this hole. It usually happens when they don't have a measured, mature way of scheduling things. They're constantly thrashing, they're constantly pushing things out, they're constantly multitasking. You end up with massive amounts of tech debt. You never go back to clean it up. Okay, you're going to have a low quality product, and the most important thing you could work on is cleaning up that product or quality. But if you are where we are, and I think also the best software companies are, your product is a pretty good quality. Treat the bugs as any other thing that needs to be prioritized, trade it off against other value you could deliver to more users more of the time. And to add some into that too, I think it's easy to think that bugs are the things that need fixing. But really, it could be the user experience isn't very good, or something isn't very clear, or this copy, it's not, the copy isn't good, or doesn't make sense, or the instructions aren't clear, or this flow takes too many steps. And these aren't bugs. I mean, that you could classify them as them, I suppose, but they're really just flaws in the product or maybe inefficient approaches to something. And that might be far more important than something that's quote broken. But if you just focus on brokenness, and you just assume everything else that works works well, then you're never going to really improve the product in other ways. It probably mattered more than plugging the holes, things that people might fall into. So I think that's a really important thing. You can get sort of lost in fixing things that are broken, and then not attributing any brokenness to anything else because it works, but works how well. That's the real question. I think there's a great way of thinking of this is that there exists a lot of extremely high quality software measured in the sense of it has no bugs or very few bugs that no one gives two hoots about and are not using and are not paying for. Perfectly bad software, basically. Perfectly bad. Yeah. Exactly. But just creating high quality, quote unquote, high quality software, bug free software, is not nearly sufficient for you to have a successful business. Right? So weigh those two things up, don't create shitty software. Although I will actually say to put it to a point, I would rather you create low quality software that people want than you create high quality software that no one buys. Low quality software that people want, that can be fixed. You can fix those bugs if you have customers and revenue and whatever coming in. You can't fix a bad product in the sense of a fault free one that no one cares about. That's a much harder thing to correct for. I think the myopia that Jason identifies here is very prevalent amongst the engineering types. We have this sense of narrowing in on bugs because they can fit on a checklist. They can be checked off. Checking off like our onboarding process sucks. That's very fussy, right? But it may very well be worth a thousand bug fixes to correct what the onboarding is like. Well, I also can't help but think that customer support and bugs kind of go hand in hand because you want a company where you feel like you can reach out and say, here's the issue that I'm having and I'm having this problem versus like, you know, there's so many companies that I'm like, I'm never going to reach out because they're never going to respond to me. And I'm just not going to use the product. That's to me like a bug in the company too. So this is something we talked about in, it doesn't have to be crazy at work, which is that your company is a product as well. We actually reference this that what are the bugs in your company? Like what doesn't run well in your company is something that you should really look at. And that would be an example. Like if you already feel like you'll never hear from this company, you've already written them off. Like it doesn't matter how good or bad their software is, but if their service is terrible or they don't feel accessible or reachable or whatever, or they don't feel like they have your back, then you're out no matter how damn good it is. So that in my opinion would be a bug. We're going to call it that we're kind of classifying it a bug in the company itself that needs to be fixed far more, I would say faster perhaps than some obscure thing that's in the software that is easy to track as a checkbox. This is one of these emotions I get all the time when I deal with the big tech conglomerates. Like I never even factor in that I could write Gmail to report an issue because I just have no confidence whatsoever that anyone will even look at it. So I think when we say this is one of the more nuanced takes we need to sort of process here because like we actually do look at the stuff. It's not that no one will ever look at a bug report coming in. People will absolutely look at it. It will get filtered through. It's just that having the humility to accept reality that A, the software is going to have bugs and B, you can't fix all of them and C, you shouldn't, does not undermine at all that every customer out there who reports an issue deserves to have someone legitimately look at it because if there weren't, how do you even know whether it's a big issue or a small issue? Right? You absolutely need humans to be part of that process and you need to have faith or I prefer to have faith in the companies I buy from that you know what, they're going to take me seriously. That's really the thing with something like Gmail which I used for I don't know 15 years. I found all sorts of stuff where I'm like this is not quite right or this is not quite right and you're like never once did it occur to me to write Google to talk about it right and thankfully we have tons of people writing us all the time to report little things and sometimes big things and sometimes and this is where the hard thing is it's a trickle of little things that actually unearth the fact that there is a big thing. The first report you go like oh maybe this is a minority issue or whatever weird combination then you hear the second one then you hear the third one and you go like uh-oh pull the cord. Okay well with that we're going to wrap it up. I'm also going to link in our show notes to our developers blog which is at dev.37signals.com that's where some of our developers write about some of their processes you can check that out as well. Rework is a production of 37 signals you can find show notes and transcripts on our website at 37signals.com podcast full video episodes are also available on twitter and youtube and if you have a question for Jason or David about a better way to work and run your business leave us a voicemail at 708-628-7850 or you can send us an email at rework at 37signals.com",
	"podcast_details":{
		"episode_image":"https://cdn-icons-png.flaticon.com/512/5225/5225800.png",
		"episode_title" : "Software Has Bugs"
	},
	"podcast_summary" : "A podcast by 37signals about the better way to work and run your business. Hosted by Kimberly Rhodes, the Rework podcast features the co-founders of 37signals (the makers of Basecamp and Hey), Jason Fried and David Heinemeier Hansson sharing their unique perspective on business and entrepreneurship.",
	"podcast_guest":{
		"name":"David Heinemeier Hansson",
		"summary":"David Heinemeier Hansson is a Danish programmer and racing driver. As a programmer, he is the creator of the popular Ruby on Rails web development framework and the Instiki wiki. He is also a partner at the web-based software development firm 37signals.Hansson co-wrote Agile Web Development with Rails with Dave Thomas in 2005 as part of The Facets of Ruby Series. He also co-wrote Getting Real, Rework, Remote, and It Doesn't Have to Be Crazy at Work with Jason Fried."
	},
	"podcast_highlights":"Key moments in the podcast text include 1. Bugs are normal and accepting reality is important in software development. 2. Bugs are not a representation of human failings, but a natural side effect of software development. 3. Bugs are prevalent in all software that has complexity or users.4. Bugs can have different levels of impact, ranging from minor annoyances to serious issues. 5. A bug may be glaring and obvious to one user, but not to others who use the software differently. 6. Prioritizing bug fixing is crucial, but not all bugs will be fixed, especially lower priority ones. 7. Code red and code yellow are designations for bugs of different levels of severity, and they prompt different responses. 8. The Toyota production line concept of stopping the assembly line to fix problems can be applied to software development. 9. The on-call team is responsible for fixing bugs, but everyone in the company is responsible for maintaining software quality. 10. Bugs are not the only issues that need fixing; flaws in the product and user experience should also be addressed. 11. Bugs in the company itself, such as poor customer service, can be just as detrimental as bugs in the software. 12. Customer bug reports should be taken seriously and addressed, but not all bugs can or should be fixed. 13. Having processes and habits for building software of high quality is essential. 14. Balancing bug fixing with other value-adding work is important to maintain a reasonable development pace. 15. The company itself is a product, and bugs in the company should be fixed as well"
}
